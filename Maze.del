import "Lava.del";

// x/zAxisWalls are array of vectors determining the location of each wall.
// The X in the vector for xAxisWalls determines where the wall starts on the X axis. The Y determines where it ends. The Z is where on the Z axis the wall is.
define globalvar xAxisWalls = [];
define globalvar zAxisWalls = [];

define globalvar cellStates = [];
define globalvar toVisitX   = [];
define globalvar toVisitY   = [];
define globalvar numberOfVisits = 0;
define globalvar generateStep = 1;

macro mazeWidth()  : 15;
macro mazeHeight() : 10;
define globalvar buildMazeAt = Vector(-86.56, 154.88, 83.64);
macro Scale(): 7;
// Flags, each must be double of the one before.
macro TopWall()    : 1;
macro RightWall()  : 2;
macro BottomWall() : 4;
macro LeftWall()   : 8;
macro Visited()    : 16;

rule: "Maze: Generate: Debug"
{
    CreateHudText(AllPlayers(), <"Number of nodes to be visited: <0>", CountOf(toVisitX)>);
}

rule: "Maze: Generate: Initial states"
if (generateStep == 1)
{
    define column = [];
    for (define y = 0; y < mazeHeight(); y++)
        column[y] = 15;

    for (define x = 0; x < mazeWidth(); x++)
        cellStates[x] = column;
    
    generateStep = 2;
}

define globalvar xOffsets = [0,1,0,-1];
define globalvar yOffsets = [1,0,-1,0];

rule: "Maze: Generate: Visit Cells"
if (generateStep == 2)
{
    define initialX = RandomInteger(0, mazeWidth() - 1);
    define initialY = RandomInteger(0, mazeHeight() - 1);
    // define initialX = 0;
    // define initialY = 0;

    ModifyGlobalVariable(toVisitX, Operation.AppendToArray, initialX);
    ModifyGlobalVariable(toVisitY, Operation.AppendToArray, initialY);

    cellStates[initialX][initialY] += Visited();

    while (CountOf(toVisitX) > 0)
    {
        define order = RandomizedArray([0,1,2,3]);
        //define order = [0,1,2,3];

        define x = LastOf(toVisitX);
        define y = LastOf(toVisitY);

        define removeAt = CountOf(toVisitX) - 1;

        foreach (define i in order)
        {
            define dirX = xOffsets[i];
            define dirY = yOffsets[i];
            define checkX = x + dirX;
            define checkY = y + dirY;

            if (checkX >= 0 && checkY >= 0 && checkX < mazeWidth() && checkY < mazeHeight() && cellStates[checkX][checkY] < Visited())
            {
                define thisWall = -1;
                define neighborWall = -1;

                // Neighbor is to the right
                if (dirX == 1)
                {
                    thisWall = RightWall();
                    neighborWall = LeftWall();
                }
                // Neighbor is to the left
                else if (dirX == -1)
                {
                    thisWall = LeftWall();
                    neighborWall = RightWall();
                }
                // Neighbor is above
                else if (dirY == 1)
                {
                    thisWall = TopWall();
                    neighborWall = BottomWall();
                }
                // Neighbor is below
                else if (dirY == -1)
                {
                    thisWall = BottomWall();
                    neighborWall = TopWall();
                }

                cellStates[x][y] -= thisWall;
                cellStates[checkX][checkY] -= neighborWall;
                cellStates[checkX][checkY] += Visited();
                ModifyGlobalVariable(toVisitX, Operation.AppendToArray, checkX);
                ModifyGlobalVariable(toVisitY, Operation.AppendToArray, checkY);
            }
        }

        MinWait();

        ModifyGlobalVariable(toVisitX, Operation.RemoveFromArrayByIndex, removeAt);
        ModifyGlobalVariable(toVisitY, Operation.RemoveFromArrayByIndex, removeAt);
    }

    generateStep = 3;
}

rule: "Maze: Generate: Create Walls: X axis"
if (generateStep == 3)
{
    DestroyAllEffects();

    for (define z = 0; z <= mazeHeight(); z++)
    {
        define topLineStart = -1;
        define bottomLineStart = -1;

        for (define x = 0; x < mazeWidth(); x++)
        {
            define cellCheck = cellStates[x][z] - Visited();

            // Left wall
            if (cellCheck >= LeftWall())
            {
                cellCheck -= LeftWall();
            }
            
            // Bottom wall
            if (cellCheck >= BottomWall())
            {
                cellCheck -= BottomWall();
                if (bottomLineStart == -1 && z == 0) bottomLineStart = x; // = z should be = x?
            }

            // Right wall
            if (cellCheck >= RightWall())
                cellCheck -= RightWall();
            
            // Top wall
            if (cellCheck >= TopWall())
            {
                cellCheck -= TopWall();
                if (topLineStart == -1) topLineStart = x;
            }
            else if (topLineStart != -1)
            {
                ModifyGlobalVariable(xAxisWalls, Operation.AppendToArray, 
                    Vector(
                        // Wall start
                        (topLineStart - 0.5) * Scale(),
                        // Wall end
                        (x - 1 + 0.5) * Scale(),
                        // Wall Z axis
                        (z + 0.5) * Scale()
                    )
                );
                topLineStart = -1;
            }
        }

        if (topLineStart != -1)
        {
            ModifyGlobalVariable(xAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (topLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeWidth() - 1 + 0.5) * Scale(),
                    // Wall Z axis
                    (z + 0.5) * Scale()
                )
            );
        }
        if (bottomLineStart != -1)
        {
            ModifyGlobalVariable(xAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (bottomLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeWidth() - 1 + 0.5) * Scale(),
                    // Wall Z axis
                    (z - 0.5) * Scale()
                )
            );
        }
    }

    foreach (define wallData in xAxisWalls)
    {
        wallData = Vector(
            XOf(buildMazeAt) + XOf(wallData),
            XOf(buildMazeAt) + YOf(wallData),
            ZOf(buildMazeAt) + ZOf(wallData)
        );

        CreateBeamEffect(
            AllPlayers(),
            BeamType.GrappleBeam,
            Vector(XOf(wallData), YOf(buildMazeAt), ZOf(wallData)),
            Vector(YOf(wallData), YOf(buildMazeAt), ZOf(wallData)),
            Color.Red,
            EffectRev.VisibleTo
        );
    }

    generateStep = 4;
}

rule: "Maze: Generate: Create Walls: Z axis"
if (generateStep == 4)
{
    for (define x = 0; x < mazeWidth(); x++)
    {
        define rightLineStart = -1;
        define leftLineStart = -1;

        for (define z = 0; z < mazeHeight(); z++)
        {
            define cellCheck = cellStates[x][z] - Visited();

            // Left wall
            if (cellCheck >= LeftWall())
            {
                cellCheck -= LeftWall();
                if (leftLineStart == -1 && x == 0) leftLineStart = z; // z to x? opposite of whats above
            }
            
            // Bottom wall
            if (cellCheck >= BottomWall())
                cellCheck -= BottomWall();
            
            // Right wall
            if (cellCheck >= RightWall())
            {
                cellCheck -= RightWall();
                if (rightLineStart == -1) rightLineStart = z;
            }
            else if (rightLineStart != -1)
            {
                ModifyGlobalVariable(zAxisWalls, Operation.AppendToArray, 
                    Vector(
                        // Wall start
                        (rightLineStart - 0.5) * Scale(),
                        // Wall end
                        (z - 1 + 0.5) * Scale(),
                        // Wall x axis
                        (x + 0.5) * Scale()
                    )
                );
                rightLineStart = -1;
            }
            
            // Top wall
            if (cellCheck >= TopWall())
                cellCheck -= TopWall();
        }

        if (rightLineStart != -1)
        {
            ModifyGlobalVariable(zAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (rightLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeHeight() - 1 + 0.5) * Scale(),
                    // Wall x axis
                    (x + 0.5) * Scale()
                )
            );
        }
        if (leftLineStart != -1)
        {
            ModifyGlobalVariable(zAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (leftLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeHeight() - 1 + 0.5) * Scale(),
                    // Wall x axis
                    (x - 0.5) * Scale()
                )
            );
        }
    }

    foreach (define wallData in zAxisWalls)
    {
        wallData = Vector(
            ZOf(buildMazeAt) + XOf(wallData),
            ZOf(buildMazeAt) + YOf(wallData),
            XOf(buildMazeAt) + ZOf(wallData)
        );

        CreateBeamEffect(
            AllPlayers(),
            BeamType.GrappleBeam,
            Vector(ZOf(wallData), YOf(buildMazeAt), XOf(wallData)),
            Vector(ZOf(wallData), YOf(buildMazeAt), YOf(wallData)),
            Color.Red,
            EffectRev.VisibleTo
        );
    }

    generateStep = 5;
}

rule: "TP players into maze"
if (generateStep == 5)
{
    foreach (define player in AllPlayers())
    {
        Teleport(player, Vector(
           XOf(buildMazeAt) + (RandomInteger(0, mazeWidth()) * Scale()),
           YOf(buildMazeAt),
           ZOf(buildMazeAt) + (RandomInteger(0, mazeHeight()) * Scale())
        ));
    }

    generateStep = 6;
}

rule: "Maze: Kill players on walls"
if (generateStep == 6)
{
    foreach (define player in AllPlayers())
    {
        define px = XOf(PositionOf(player));
        define pz = ZOf(PositionOf(player));
        if (     IsTrueForAny(xAxisWalls, AbsoluteValue(pz - ZOf(ArrayElement())) < 1 && px > XOf(ArrayElement()) && YOf(ArrayElement()) > px))
            Kill(player, null);
        else if (IsTrueForAny(zAxisWalls, AbsoluteValue(px - ZOf(ArrayElement())) < 1 && pz > XOf(ArrayElement()) && YOf(ArrayElement()) > pz))
        {
            Kill(player, null);
        }
    }
    LoopIfConditionIsTrue();
}