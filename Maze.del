import "Lava.del";

define globalvar cellStates = [];
define globalvar toVisitX 0 = [];
define globalvar toVisitY 1 = [];
define globalvar generateStep = 0;

macro mazeWidth()  : 10;
macro mazeHeight() : 10;
// Flags, each must be double of the one before.
macro TopWall()    : 1;
macro RightWall()  : 2;
macro BottomWall() : 4;
macro LeftWall()   : 8;
macro Visited()    : 16;
// The current visiting cell

rule: "Maze: Generate: Debug"
{
    CreateHudText(AllPlayers(), <"Number of nodes to be visited: <0>", CountOf(toVisitX)>);
}

rule: "Maze: Generate: Initial states"
if (IsTrueForAny(AllPlayers(), HasSpawned(ArrayElement())))
if (generateStep == 0)
{
    define column = [];
    for (define y = 0; y < mazeHeight(); y++)
        column[y] = 15;

    for (define x = 0; x < mazeWidth(); x++)
        cellStates[x] = column;
    
    generateStep = 1;
}

define globalvar xOffsets = [0,1,0,-1];
define globalvar yOffsets = [1,0,-1,0];

rule: "Maze: Generate: Visit Cells"
if (generateStep == 1)
{
    define initialX = RandomInteger(0, mazeWidth() - 1);
    define initialY = RandomInteger(0, mazeHeight() - 1);
    // define initialX = 0;
    // define initialY = 0;

    ModifyGlobalVariable(toVisitX, Operation.AppendToArray, initialX);
    ModifyGlobalVariable(toVisitY, Operation.AppendToArray, initialY);

    cellStates[initialX][initialY] += Visited();

    while (CountOf(toVisitX) > 0)
    {
        define order = RandomizedArray([0,1,2,3]);
        //define order = [0,1,2,3];

        define x = LastOf(toVisitX);
        define y = LastOf(toVisitY);

        define removeAt = CountOf(toVisitX) - 1;

        foreach (define i in order)
        {
            define dirX = xOffsets[i];
            define dirY = yOffsets[i];
            define checkX = x + dirX;
            define checkY = y + dirY;

            if (checkX >= 0 && checkY >= 0 && checkX < mazeWidth() && checkY < mazeHeight() && cellStates[checkX][checkY] < Visited())
            {
                define thisWall = -1;
                define neighborWall = -1;

                // Neighbor is to the right
                if (dirX == 1)
                {
                    thisWall = RightWall();
                    neighborWall = LeftWall();
                }
                // Neighbor is to the left
                else if (dirX == -1)
                {
                    thisWall = LeftWall();
                    neighborWall = RightWall();
                }
                // Neighbor is above
                else if (dirY == 1)
                {
                    thisWall = TopWall();
                    neighborWall = BottomWall();
                }
                // Neighbor is below
                else if (dirY == -1)
                {
                    thisWall = BottomWall();
                    neighborWall = TopWall();
                }

                MinWait();

                cellStates[x][y] -= thisWall;
                cellStates[checkX][checkY] -= neighborWall;
                cellStates[checkX][checkY] += Visited();
                ModifyGlobalVariable(toVisitX, Operation.AppendToArray, checkX);
                ModifyGlobalVariable(toVisitY, Operation.AppendToArray, checkY);
            }
            MinWait();
        }

        MinWait();

        ModifyGlobalVariable(toVisitX, Operation.RemoveFromArrayByIndex, removeAt);
        ModifyGlobalVariable(toVisitY, Operation.RemoveFromArrayByIndex, removeAt);
    }

    // debug1 = cellStates[0];
    // debug2 = cellStates[1];
    // debug3 = cellStates[2];
    // debug4 = cellStates[3];
    // debug5 = cellStates[4];
    // debug6 = cellStates[5];
    // debug7 = cellStates[6];
    // debug8 = cellStates[7];
    // debug9 = cellStates[8];
    // debug10 = cellStates[9];

    generateStep = 2;
}

define globalvar buildMazeAt = Vector(17, 154.88, 121.01);

macro Scale(): 3;

rule: "Maze: Generate: Create walls: Top"
if (generateStep == 2)
{
    for (define y = 0; y < mazeHeight(); y++)
    {
        define topWallStart = -1;
        define topWallEnd = -1;

        for (define x = 0; x < mazeWidth(); x++)
        {
            define cellCheck = cellStates[x][y] - Visited();

            if (cellCheck >= LeftWall())
            {
                cellCheck -= LeftWall();
            }
            if (cellCheck >= BottomWall())
            {
                cellCheck -= BottomWall();
            }
            if (cellCheck >= RightWall())
            {
                cellCheck -= RightWall();
            }
            if (cellCheck >= TopWall())
            {
                cellCheck -= TopWall();

                if (topWallStart == -1) topWallStart = x;
                topWallEnd = x;
            }
            else if (topWallStart != -1)
            {
                CreateBeamEffect(
                    AllPlayers(),
                    BeamType.GrappleBeam,
                    buildMazeAt + Vector(topWallStart * Scale(), 15, y * Scale()),
                    buildMazeAt + Vector((topWallEnd + 1) * Scale(), 15, y * Scale()),
                    Color.Red,
                    EffectRev.VisibleTo
                );
                // CreateEffect(
                //     AllPlayers(),
                //     Effect.Sphere,
                //     Color.Red,
                //     buildMazeAt + Vector(topWallStart * Scale(), 15, y * Scale()),
                //     0.25,
                //     EffectRev.VisibleTo
                // );
                // CreateEffect(
                //     AllPlayers(),
                //     Effect.Sphere,
                //     Color.Red,
                //     buildMazeAt + Vector((topWallEnd + 1) * Scale(), 15, y * Scale()),
                //     0.25,
                //     EffectRev.VisibleTo
                // );
                topWallStart = -1;
            }
            if (cellCheck != 0) SmallMessage(AllPlayers(), <"cellCheck equals <0> instead of 0.", cellCheck>);
        }
    }

    for (define x = 0; x < mazeWidth(); x++)
    {
        define leftWallStart = -1;
        define leftWallEnd = -1;

        for (define y = 0; y < mazeHeight(); y++)
        {
            define cellCheck = cellStates[x][y] - Visited();

            if (cellCheck >= LeftWall())
            {
                if (leftWallStart == -1) leftWallStart = y;
                leftWallEnd = y;
            }
            else if (leftWallStart != -1)
            {
                CreateBeamEffect(
                    AllPlayers(),
                    BeamType.GrappleBeam,
                    buildMazeAt + Vector(x * Scale(), 15, leftWallStart * Scale()),
                    buildMazeAt + Vector(x * Scale(), 15, (leftWallEnd + 1) * Scale()),
                    Color.Red,
                    EffectRev.VisibleTo
                );
                CreateEffect(
                    AllPlayers(),
                    Effect.Sphere,
                    Color.Blue,
                    buildMazeAt + Vector(x * Scale(), 15, leftWallStart * Scale()),
                    0.25,
                    EffectRev.VisibleTo
                );
                CreateEffect(
                    AllPlayers(),
                    Effect.Sphere,
                    Color.Blue,
                    buildMazeAt + Vector(x * Scale(), 15, (leftWallEnd + 1) * Scale()),
                    0.25,
                    EffectRev.VisibleTo
                );
                leftWallEnd = -1;
            }
        }
    }

    generateStep = 3;
}

define globalvar debug1 2;
define globalvar debug2 3;
define globalvar debug3 4;
define globalvar debug4 5;
define globalvar debug5 6;
define globalvar debug6 7;
define globalvar debug7 8;
define globalvar debug8 9;
define globalvar debug9 10;
define globalvar debug10 11;