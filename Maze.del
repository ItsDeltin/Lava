import "Lava.del";

// x/zAxisWalls are array of vectors determining the location of each wall.
// The X in the vector for xAxisWalls determines where the wall starts on the X axis. The Y determines where it ends. The Z is where on the Z axis the wall is.
define globalvar xAxisWalls = [];
define globalvar zAxisWalls = [];

define globalvar cellStates = [];
define globalvar toVisitX   = [];
define globalvar toVisitY   = [];
define globalvar numberOfVisits = 0;
define globalvar generateStep = 1;

macro mazeWidth()  : 15;
macro mazeHeight() : 10;
define globalvar buildMazeAt = Vector(-86.56, 154.88, 83.64);
macro Scale(): 7;
// Flags, each must be double of the one before.
macro TopWall()    : 1;
macro RightWall()  : 2;
macro BottomWall() : 4;
macro LeftWall()   : 8;
macro Visited()    : 16;

macro mazePos(define pos): (pos - buildMazeAt) / Scale();
macro randomMazeSpot(): Vector(
        XOf(buildMazeAt) + (RandomInteger(0, mazeWidth() - 1) * Scale()),
        YOf(buildMazeAt),
        ZOf(buildMazeAt) + (RandomInteger(0, mazeHeight() - 1) * Scale())
    );

disabled rule: "Maze: Generate: Debug"
{
    CreateHudText(AllPlayers(), <"Number of nodes to be visited: <0>", CountOf(toVisitX)>);
    CreateHudText(AllPlayers(), <"Host player pos: <0>", mazePos(PositionOf(HostPlayer()))>);
}

disabled rule: "Maze: Generate: Initial states"
if (generateStep == 1)
{
    define column = [];
    for (define y = 0; y < mazeHeight(); y++)
        column[y] = 15;

    for (define x = 0; x < mazeWidth(); x++)
        cellStates[x] = column;
    
    generateStep = 2;
}

define globalvar xOffsets = [0,1,0,-1];
define globalvar yOffsets = [1,0,-1,0];

disabled rule: "Maze: Generate: Visit Cells"
if (generateStep == 2)
{
    define initialX = RandomInteger(0, mazeWidth() - 1);
    define initialY = RandomInteger(0, mazeHeight() - 1);
    // define initialX = 0;
    // define initialY = 0;

    ModifyGlobalVariable(toVisitX, Operation.AppendToArray, initialX);
    ModifyGlobalVariable(toVisitY, Operation.AppendToArray, initialY);

    cellStates[initialX][initialY] += Visited();

    while (CountOf(toVisitX) > 0)
    {
        define order ! = RandomizedArray([0,1,2,3]);
        //define order = [0,1,2,3];

        define x ! = LastOf(toVisitX);
        define y ! = LastOf(toVisitY);

        define removeAt = CountOf(toVisitX) - 1;

        foreach (define i in order)
        {
            define dirX = xOffsets[i];
            define dirY = yOffsets[i];
            define checkX = x + dirX;
            define checkY = y + dirY;

            if (checkX >= 0 && checkY >= 0 && checkX < mazeWidth() && checkY < mazeHeight() && cellStates[checkX][checkY] < Visited())
            {
                define thisWall = -1;
                define neighborWall = -1;

                // Neighbor is to the right
                if (dirX == 1)
                {
                    thisWall = RightWall();
                    neighborWall = LeftWall();
                }
                // Neighbor is to the left
                else if (dirX == -1)
                {
                    thisWall = LeftWall();
                    neighborWall = RightWall();
                }
                // Neighbor is above
                else if (dirY == 1)
                {
                    thisWall = TopWall();
                    neighborWall = BottomWall();
                }
                // Neighbor is below
                else if (dirY == -1)
                {
                    thisWall = BottomWall();
                    neighborWall = TopWall();
                }

                cellStates[x][y] -= thisWall;
                cellStates[checkX][checkY] -= neighborWall;
                cellStates[checkX][checkY] += Visited();
                ModifyGlobalVariable(toVisitX, Operation.AppendToArray, checkX);
                ModifyGlobalVariable(toVisitY, Operation.AppendToArray, checkY);
            }
        }

        MinWait();

        ModifyGlobalVariable(toVisitX, Operation.RemoveFromArrayByIndex, removeAt);
        ModifyGlobalVariable(toVisitY, Operation.RemoveFromArrayByIndex, removeAt);
    }

    generateStep = 3;
}

disabled rule: "Maze: Generate: Create Walls: X axis"
if (generateStep == 3)
{
    DestroyAllEffects();

    for (define z ! = 0; z <= mazeHeight(); z++)
    {
        define topLineStart ! = -1;
        define bottomLineStart ! = -1;

        for (define x ! = 0; x < mazeWidth(); x++)
        {
            define cellCheck = cellStates[x][z] - Visited();

            // Left wall
            if (cellCheck >= LeftWall())
            {
                cellCheck -= LeftWall();
            }
            
            // Bottom wall
            if (cellCheck >= BottomWall())
            {
                cellCheck -= BottomWall();
                if (bottomLineStart == -1 && z == 0) bottomLineStart = x; // = z should be = x?
            }

            // Right wall
            if (cellCheck >= RightWall())
                cellCheck -= RightWall();
            
            // Top wall
            if (cellCheck >= TopWall())
            {
                cellCheck -= TopWall();
                if (topLineStart == -1) topLineStart = x;
            }
            else if (topLineStart != -1)
            {
                ModifyGlobalVariable(xAxisWalls, Operation.AppendToArray, 
                    Vector(
                        // Wall start
                        (topLineStart - 0.5) * Scale(),
                        // Wall end
                        (x - 1 + 0.5) * Scale(),
                        // Wall Z axis
                        (z + 0.5) * Scale()
                    )
                );
                topLineStart = -1;
            }
        }

        if (topLineStart != -1)
        {
            ModifyGlobalVariable(xAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (topLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeWidth() - 1 + 0.5) * Scale(),
                    // Wall Z axis
                    (z + 0.5) * Scale()
                )
            );
        }
        if (bottomLineStart != -1)
        {
            ModifyGlobalVariable(xAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (bottomLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeWidth() - 1 + 0.5) * Scale(),
                    // Wall Z axis
                    (z - 0.5) * Scale()
                )
            );
        }
    }

    foreach (define wallData in xAxisWalls)
    {
        wallData = Vector(
            XOf(buildMazeAt) + XOf(wallData),
            XOf(buildMazeAt) + YOf(wallData),
            ZOf(buildMazeAt) + ZOf(wallData)
        );

        CreateBeamEffect(
            AllPlayers(),
            BeamType.BadBeam,
            Vector(XOf(wallData), YOf(buildMazeAt), ZOf(wallData)),
            Vector(YOf(wallData), YOf(buildMazeAt), ZOf(wallData)),
            Color.Red,
            EffectRev.VisibleTo
        );
    }

    generateStep = 4;
}

disabled rule: "Maze: Generate: Create Walls: Z axis"
if (generateStep == 4)
{
    for (define x ! = 0; x < mazeWidth(); x++)
    {
        define rightLineStart ! = -1;
        define leftLineStart ! = -1;

        for (define z ! = 0; z < mazeHeight(); z++)
        {
            define cellCheck = cellStates[x][z] - Visited();

            // Left wall
            if (cellCheck >= LeftWall())
            {
                cellCheck -= LeftWall();
                if (leftLineStart == -1 && x == 0) leftLineStart = z; // z to x? opposite of whats above
            }
            
            // Bottom wall
            if (cellCheck >= BottomWall())
                cellCheck -= BottomWall();
            
            // Right wall
            if (cellCheck >= RightWall())
            {
                cellCheck -= RightWall();
                if (rightLineStart == -1) rightLineStart = z;
            }
            else if (rightLineStart != -1)
            {
                ModifyGlobalVariable(zAxisWalls, Operation.AppendToArray, 
                    Vector(
                        // Wall start
                        (rightLineStart - 0.5) * Scale(),
                        // Wall end
                        (z - 1 + 0.5) * Scale(),
                        // Wall x axis
                        (x + 0.5) * Scale()
                    )
                );
                rightLineStart = -1;
            }
            
            // Top wall
            if (cellCheck >= TopWall())
                cellCheck -= TopWall();
        }

        if (rightLineStart != -1)
        {
            ModifyGlobalVariable(zAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (rightLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeHeight() - 1 + 0.5) * Scale(),
                    // Wall x axis
                    (x + 0.5) * Scale()
                )
            );
        }
        if (leftLineStart != -1)
        {
            ModifyGlobalVariable(zAxisWalls, Operation.AppendToArray, 
                Vector(
                    // Wall start
                    (leftLineStart - 0.5) * Scale(),
                    // Wall end
                    (mazeHeight() - 1 + 0.5) * Scale(),
                    // Wall x axis
                    (x - 0.5) * Scale()
                )
            );
        }
    }

    foreach (define wallData in zAxisWalls)
    {
        wallData = Vector(
            ZOf(buildMazeAt) + XOf(wallData),
            ZOf(buildMazeAt) + YOf(wallData),
            XOf(buildMazeAt) + ZOf(wallData)
        );

        CreateBeamEffect(
            AllPlayers(),
            BeamType.BadBeam,
            Vector(ZOf(wallData), YOf(buildMazeAt), XOf(wallData)),
            Vector(ZOf(wallData), YOf(buildMazeAt), YOf(wallData)),
            Color.Red,
            EffectRev.VisibleTo
        );
    }

    generateStep = 5;
}

disabled rule: "Maze: Setup players"
if (generateStep == 5)
{
    foreach (define player in AllPlayers())
    {
        Teleport(player, randomMazeSpot());
    }

    Wait(1);

    CreateDummyBot(Hero.Roadhog, Team.Team1, -1, randomMazeSpot(), Vector());
    navigator = LastCreatedEntity();
    MinWait();
    Teleport(navigator, randomMazeSpot());

    generateStep = 6;
}

disabled rule: "Maze: Kill players on walls"
if (generateStep == 6)
{
    foreach (define player in AllPlayers())
    if (!IsButtonHeld(player, Button.Crouch) && navigator != player)
    {
        define px = XOf(PositionOf(player));
        define pz = ZOf(PositionOf(player));
        if (     IsTrueForAny(xAxisWalls, AbsoluteValue(pz - ZOf(ArrayElement())) < 1 && px > XOf(ArrayElement()) && YOf(ArrayElement()) > px))
            Kill(player, null);
        else if (IsTrueForAny(zAxisWalls, AbsoluteValue(px - ZOf(ArrayElement())) < 1 && pz > XOf(ArrayElement()) && YOf(ArrayElement()) > pz))
        {
            Kill(player, null);
        }

        Wait(0.2);
    }
    LoopIfConditionIsTrue();
}

define globalvar navigator;
define globalvar navigateTo;
define globalvar walkPath = [];
define globalvar isGettingPath ! = false;

define globalvar chosenPathEffects;

disabled rule: "Maze: A*: Nav"
if (generateStep >= 5)
if (IsButtonHeld(HostPlayer(), Button.Interact))
{
    navigateTo = mazePos(PositionOf(HostPlayer()));
    SmallMessage(AllPlayers(), <"Navigating to <0>", navigateTo>);

    isGettingPath = true;

    define navigateToX ! = RoundToInteger(XOf(navigateTo), Rounding.Nearest);
    define navigateToZ ! = RoundToInteger(ZOf(navigateTo), Rounding.Nearest);

    define originX ! = RoundToInteger(XOf(mazePos(PositionOf(navigator))), Rounding.Nearest);
    define originZ ! = RoundToInteger(ZOf(mazePos(PositionOf(navigator))), Rounding.Nearest);

    define aStarCheck = [];
    ModifyGlobalVariable(aStarCheck, Operation.AppendToArray, Vector(originX, -1, originZ));

    define found ! = -1;

    define visited = [];

    for (define i ! = 0; i < CountOf(aStarCheck) && found == -1; i++)
    {
        define x ! = XOf(aStarCheck[i]);
        define z ! = ZOf(aStarCheck[i]);
        define cellCheck ! = cellStates[x][z] - 16;
        visited[x][z] = true;
        Wait(0.2);

        if (x == navigateToX && z == navigateToZ)
        {
            found = i;
        }
        else
        {
            // Left wall
            if (cellCheck >= LeftWall())
                cellCheck -= LeftWall();
            // No left wall
            else if (x > 0 && !visited[x - 1][z] /*!IsTrueForAny(aStarCheck, XOf(ArrayElement()) == x - 1 && ZOf(ArrayElement()) == z)*/)
                ModifyGlobalVariable(aStarCheck, Operation.AppendToArray, Vector(x - 1, i, z));
            
            // Bottom wall
            if (cellCheck >= BottomWall())
                cellCheck -= BottomWall();
            // No bottom wall
            else if (z > 0 && !visited[x][z - 1] /*!IsTrueForAny(aStarCheck, XOf(ArrayElement()) == x && ZOf(ArrayElement()) == z - 1)*/)
                ModifyGlobalVariable(aStarCheck, Operation.AppendToArray, Vector(x, i, z - 1));
            
            MinWait();

            // Right wall
            if (cellCheck >= RightWall())
                cellCheck -= RightWall();
            // No right wall
            else if (x < mazeWidth() - 1 && !visited[x + 1][z] /*!IsTrueForAny(aStarCheck, XOf(ArrayElement()) == x + 1 && ZOf(ArrayElement()) == z)*/)
                ModifyGlobalVariable(aStarCheck, Operation.AppendToArray, Vector(x + 1, i, z));
            
            // Top wall
            if (cellCheck >= TopWall())
                cellCheck -= TopWall();
            // No top wall
            else if (z < mazeHeight() - 1 && !visited[x][z + 1] /*!IsTrueForAny(aStarCheck, XOf(ArrayElement()) == x && ZOf(ArrayElement()) == z + 1)*/)
                ModifyGlobalVariable(aStarCheck, Operation.AppendToArray, Vector(x, i, z + 1));
        }
    }

    SmallMessage(AllPlayers(), "found ya");

    DestroyEffectArray(chosenPathEffects);
    chosenPathEffects = [];

    walkPath = [];
    while (found != -1)
    {
        walkPath = [Vector(
                XOf(buildMazeAt) + (XOf(aStarCheck[found]) * Scale()),
                YOf(buildMazeAt),
                ZOf(buildMazeAt) + (ZOf(aStarCheck[found]) * Scale())
            ),
            walkPath];
        CreateEffect(AllPlayers(), Effect.Sphere, Color.Purple, FirstOf(walkPath), 0.25, EffectRev.VisibleTo);
        chosenPathEffects = Append(chosenPathEffects, LastCreatedEntity());
        found = YOf(aStarCheck[found]);
    }

    aStarCheck = [];

    isGettingPath = false;
    SmallMessage(AllPlayers(), "Found path!");
}