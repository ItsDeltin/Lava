import "Reinhardt.del";
import "Ball.del";
import "Score.del";
import "Lasers.del";
import "Volleyball.del";
import "Maze.del";
import "Debug Tools.del";
import "customGameSettings.json";

globalvar define origin = Vector(-0.18, 154.88, 60);
playervar define isWorkingDummy;
playervar define doRespawn !;
globalvar Mode gamemode = Mode.Waiting;
// 0 = Waiting
// 1 = Soccer countdown
// 2 = Soccer
// 3 = Volleyball
// 4 = Lasers
// 5 = Maze

enum Mode
{
    Waiting,
    SoccerCountdown,
    Soccer,
    Volleyball,
    Lasers,
    Maze
}

rule: "OSTW"
{
    CreateHudText(
        VisibleTo: AllPlayers(),
        Text: "Created by Deltin with OSTW",
        TextColor: Color.SkyBlue,
        Location: Location.Right,
        Spectators: Spectators.VisibleAlways,
        SortOrder: -2
    );
    CreateHudText(
        VisibleTo: AllPlayers(),
        Subheader: "https://github.com/ItsDeltin/Overwatch-Script-To-Workshop",
        SubheaderColor: Color.Blue,
        Location: Location.Right,
        Spectators: Spectators.VisibleAlways,
        SortOrder: -1
    );
}

rule: "Generic Respawn"
Event.OngoingPlayer
if (HasSpawned())
if (IsAlive())
if (!isWorkingDummy)
{
    doRespawn = true;
}

rule: "Respawn"
Event.OngoingPlayer
if (doRespawn)
if (!isWorkingDummy)
{
    Respawn();
    MinWait();
    // Volleyball and initial soccer
    if (gamemode >= 0 && gamemode <= 3)
    {
        define useSpawnArray;
        if (gamemode == 1)
        {
            if (TeamOf(EventPlayer()) == Team.Team1)
                useSpawnArray = availableBlueSpawns;
            else
                useSpawnArray = availableRedSpawns;
        }
        else useSpawnArray = [1,2,3,4,5];
        define spawnAt ! = RandomValueInArray(useSpawnArray);

        Teleport(EventPlayer(), Vector(TeamOf(EventPlayer()) == Team.Team1 ? 60 : -60, 154.88, (150 - 30) + (((150 + 30) - (150 - 30))/5)*spawnAt));

        if (gamemode == 1)
        {
            if (TeamOf(EventPlayer()) == Team.Team1)
                ModifyVariable(availableBlueSpawns, Operation.RemoveFromArrayByValue, spawnAt);
            else
                ModifyVariable(availableRedSpawns, Operation.RemoveFromArrayByValue, spawnAt);
            
            inputEnabled = false;
        }
    } 
    // Maze
    else if (gamemode == 5)
        Teleport(EventPlayer(), randomMazeSpot());
    // No gamemode
    else
        Teleport(EventPlayer(), origin + Vector(20, 0, 20));

    SetFacing(EventPlayer(), DirectionTowards(EyePosition(), TopPolePos()));

    doRespawn = false;
}

globalvar define availableBlueSpawns = [1,2,3,4,5];
globalvar define availableRedSpawns = [1,2,3,4,5];

define notWorkingDummy(): FilteredArray(AllPlayers(), !ArrayElement().isWorkingDummy);

define rowCount(): 50;
define columnCount(): 35;

globalvar define arenaEffects = [];

rule: "Setup Arena (Disable when using Maze)"
if (CurrentGameMode() == GameMode.Skirmish)
{
    OuterWalls();

    define cliffBlue = Vector(107.07, 154.88, 63.61);
    define cliffRed = Vector(-109.08, 154.88, 65.06);
    define towerBlue = Vector(108.08, 154.88, 213.35);
    define towerRed = Vector(-108.07, 154.88, 214.81);
    define rowFraction = 1/rowCount();
    define columnFraction = 1/columnCount();

    for (define x = 0; x <= rowCount(); x++)
    {
        define a = LinearInterpolate(cliffBlue, cliffRed, x*rowFraction);
        define b = LinearInterpolate(towerBlue, towerRed, x*rowFraction);
        CreateBeamEffect(
            AllPlayers(),
            BeamType.GrappleBeam,
            a,
            b,
            Color.Red,
            EffectRev.VisibleTo
        );
        ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    }
    for (define z = 0; z <= columnCount(); z++)
    {
        define a = LinearInterpolate(cliffBlue, towerBlue, z*columnFraction);
        define b = LinearInterpolate(cliffRed, towerRed, z*columnFraction);
        CreateBeamEffect(
            AllPlayers(),
            BeamType.GrappleBeam,
            a,
            b,
            Color.Red,
            EffectRev.VisibleTo
        );
        ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    }

    // Pole flair
    CreateEffect(AllPlayers(), Effect.Orb, Color.Orange, TopPolePos(), 0.25, EffectRev.VisibleTo);
    // // ModifyGlobalVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    // CreateBeamEffect(
    //     AllPlayers(),
    //     BeamType.GoodBeam,
    //     flairPos(),
    //     TopPolePos(),
    //     Color.Red
    // );
    // // ModifyGlobalVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    // ChaseGlobalVariableAtRate(killzoneRot, 180, 25, RateChaseReevaluation.DestinationAndRate);
}

// define flairPos(): Destination(xyPolePos(136.42), DirectionFromAngles(killzoneRot, 0), 11);

// rule: "Reset killzone rot"
// if (killzoneRot == 180)
// {
//     killzoneRot = -180;
// }

// rule: "Blip end"
// if (AbsoluteValue(killzoneRot - 22.5) % 45 < 1)
// {
//     PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Red, flairPos(), 1);
// }

// define globalvar killzoneRot = -180;

void OuterWalls()
{
    // Cliff side
    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        Vector(-109.08, 158.44, 65.06),
        Vector(107.07, 158.44, 63.61),
        Color.Orange,
        EffectRev.VisibleTo
    );
    ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    // Tower side
    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        Vector(108.08, 158.44, 213.35),
        Vector(-108.07, 158.44, 214.81),
        Color.Orange,
        EffectRev.VisibleTo
    );
    ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    // Team 1 side
    // inner
    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        Vector(108.08, 158.44, 213.35),
        Vector(107.07, 158.44, 63.61),
        Color.Team1,
        EffectRev.VisibleTo
    );
    ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    // Outer
    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        Vector(115.69, 158.44, 213.35),
        Vector(115.69, 158.44, 63.61),
        Color.Team1,
        EffectRev.VisibleTo
    );
    ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    // Team 2 side
    // Inner
    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        Vector(-109.08, 158.44, 65.06),
        Vector(-108.07, 158.44, 214.81),
        Color.Team2,
        EffectRev.VisibleTo
    );
    ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
    //Outer
    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        Vector(-118.45, 158.44, 65.06),
        Vector(-118.45, 158.44, 214.81),
        Color.Team2,
        EffectRev.VisibleTo
    );
    ModifyVariable(arenaEffects, Operation.AppendToArray, LastCreatedEntity());
}

define PolePos()   : Vector(0, 154.88, 150);
define TopPolePos(): Vector(0, 161.5,  150);
define BaseOffset(): Vector(0, 0.5, 0);
define xyPolePos(define y): Vector(0, y, 150);

define isOnWall(define player): IsOnGround(player) && AbsoluteValue(YOf(PositionOf(player)) - 158.44) < 0.2;

rule: "I want to die"
if (IsButtonHeld(HostPlayer(), Button.Ultimate))
{
    CreateDummyBot(Hero.Reinhardt, NumberOfPlayers(Team.Team1) < 6 ? Team.Team1 : Team.Team2, -1, PositionOf(HostPlayer()), Vector());
}