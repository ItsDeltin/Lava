import "Lava.del";

rule: "Debug Laser Dodge"
Event.OngoingPlayer
if (IsCommunicating(EventPlayer(), Communication.Thanks))
{
    doingLasers = !doingLasers;
    rotateLasers = true;
}

define globalvar doingLasers = false;
define globalvar lasersReady ! = false;

define globalvar rotateLasers = false;
define globalvar rotationSpeed = 0; // Number of degrees per second
define globalvar laserLength = 0;
define globalvar boundaryLength = 50;

define globalvar midpoint;

define globalvar laser1Rot;
define globalvar laser2Rot;
define globalvar laser3Rot;

define globalvar laser1Effect !;
define globalvar laser2Effect !;
define globalvar laser3Effect !;
define globalvar ringEffectArray !;
define globalvar outOfRangeHUD !;

macro isOnLine(define line, define player): AbsoluteValue(cross(line, PositionOf(player))) < 200;
macro cross(define line, define pos)   : dxc(line, pos) * dyl(line) - dyc(line, pos) * dxl(line);
macro dxc(define line, define pos)     : XOf(pos) - XOf(line);
macro dyc(define line, define pos)     : ZOf(pos) - ZOf(line);
macro dxl(define line)                 : XOf(midpoint) - XOf(line);
macro dyl(define line)                 : ZOf(midpoint) - ZOf(line);

rule: "Setup laser game"
if (doingLasers)
{
    SetGravity(AllPlayers(), 90);

    midpoint = PolePos();

    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        rot(midpoint + Vector(0, 0.5, 0), laser1Rot, laserLength),
        inverseRot(midpoint + Vector(0, 0.5, 0), laser1Rot, laserLength),
        Color.Red,
        EffectRev.VisibleToPositionAndRadius
    );
    laser1Effect = LastCreatedEntity();

    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        rot(midpoint + Vector(0, 2, 0), laser2Rot, laserLength),
        inverseRot(midpoint + Vector(0, 2, 0), laser2Rot, laserLength),
        Color.Red,
        EffectRev.VisibleToPositionAndRadius
    );
    laser2Effect = LastCreatedEntity();

    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        rot(midpoint + Vector(0, 3.5, 0), laser3Rot, laserLength),
        inverseRot(midpoint + Vector(0, 3.5, 0), laser3Rot, laserLength),
        Color.Red,
        EffectRev.VisibleToPositionAndRadius
    );
    laser3Effect = LastCreatedEntity();

    if (rotateLasers)
    {
        // Create the boundary ring
        ringEffectArray = [];
        define fraction ! = 360 / boundarySubdivisions();
        for (define i ! = 0; i < boundarySubdivisions() - 1; i++)
        {
            CreateBeamEffect(
                AllPlayers(),
                BeamType.BadBeam,
                rot(midpoint, fraction * i, boundaryLength),
                rot(midpoint, fraction * (i + 1), boundaryLength),
                Color.Blue,
                EffectRev.VisibleTo
            );

            ringEffectArray = Append(ringEffectArray, LastCreatedEntity());
        }

        // Warn players to get inside the ring
        outOfRange = AllPlayers();
        CreateHudText(
            VisibleTo:outOfRange,
            Header:IconString(Icon.Warning),
            Text:"Get inside the ring!",
            HeaderColor:Color.Red,
            TextColor:Color.Yellow,
            Location:Location.Top,
            Spectators:Spectators.VisibleNever
        );
        outOfRangeHUD = LastTextID();
    }

    ChaseGlobalVariableOverTime(laserLength, 150, 5, TimeChaseReevaluation.None);
    Wait(5);
    StopChasingGlobalVariable(laserLength);
    lasersReady = true;

    if (rotateLasers)
    {
        ChaseGlobalVariableAtRate(laser1Rot, 360 * 4, rotationSpeed, RateChaseReevaluation.DestinationAndRate);
        ChaseGlobalVariableAtRate(laser2Rot, -(360 * 4), rotationSpeed * 1.25, RateChaseReevaluation.DestinationAndRate);
        ChaseGlobalVariableAtRate(laser3Rot, 360 * 3, rotationSpeed * 0.85, RateChaseReevaluation.DestinationAndRate);

        ChaseGlobalVariableOverTime(rotationSpeed, 45, 5, TimeChaseReevaluation.None);
        Wait(5);
        StopChasingGlobalVariable(rotationSpeed);
    }
}
macro boundarySubdivisions(): 10;

rule: "Clean up lasers"
if (!doingLasers)
if (lasersReady)
{
    lasersReady = false;

    ChaseGlobalVariableOverTime(laserLength, 0, 5, TimeChaseReevaluation.None);
    Wait(5);
    StopChasingGlobalVariable(laserLength);

    DestroyEffect(laser1Effect);
    DestroyEffect(laser2Effect);
    DestroyEffect(laser3Effect);
    DestroyEffectArray(ringEffectArray, 2);
    DestroyHudText(outOfRangeHUD);

    StopChasingGlobalVariable(laser1Rot);
    StopChasingGlobalVariable(laser2Rot);
    StopChasingGlobalVariable(laser3Rot);
    laser1Rot = 0;
    laser2Rot = 0;
    laser3Rot = 0;
    rotateLasers = false;
}

macro rot(define pos, define angle, define length): Destination(pos, DirectionFromAngles(angle, 0), length);
macro inverseRot(define pos, define angle, define length): Destination(pos, DirectionFromAngles(angle + 180, 0), length);

macro intersectingFrom(define rotation, define height): RayCastHitPlayer(rotation, midpoint + height, AllLivingPlayers(), null, false);

macro intersectingRot(define rotation, define height)       : intersectingFrom(       rot(midpoint + Vector(0, height, 0), rotation, laserLength), Vector(0, height, 0));
macro inverseIntersectingRot(define rotation, define height): intersectingFrom(inverseRot(midpoint + Vector(0, height, 0), rotation, laserLength), Vector(0, height, 0));

define playervar lastDamage;

macro getOutOfRange(): RemoveFromArray(AllPlayers(), PlayersWithinRadius(midpoint, boundaryLength, Team.All, RadiusLOS.Off));

rule: "Kill intersecting players"
if (doingLasers)
if (lasersReady)
{
    if (rotateLasers)
    {
        outOfRange = getOutOfRange();
        Damage(outOfRange, null, 10);
    }

    define intersecting = [];

    define line1 = rot(midpoint, laser1Rot, laserLength);
    ModifyGlobalVariable(intersecting, Operation.AppendToArray,
        FilteredArray(AllPlayers(), !IsInAir(ArrayElement()) && isOnLine(line1, ArrayElement())));

    Wait(0.05);

    define line2 = rot(midpoint, laser2Rot, laserLength);
    ModifyGlobalVariable(intersecting, Operation.AppendToArray, 
        FilteredArray(AllPlayers(), !(IsCrouching(ArrayElement()) || (IsOnGround(ArrayElement()) && IsUsingAbility1(ArrayElement()))) && isOnLine(line2, ArrayElement())));
    
    intersecting = FilteredArray(intersecting, TotalTimeElapsed() - ArrayElement().lastDamage > 1);
    intersecting.lastDamage = TotalTimeElapsed();
    Damage(intersecting, null, 170);

    Wait(0.05);
    LoopIfConditionIsTrue();
}

rule: "Finished rotating"
if (doingLasers)
if (lasersReady)
if (rotateLasers)
if (laser1Rot == 360 * 4)
if (laser2Rot == -(360 * 4))
if (laser3Rot == 360 * 3)
{
    DestroyHudText(outOfRangeHUD);
    DestroyEffectArray(ringEffectArray, 2);
    StopChasingGlobalVariable(laser1Rot);
    StopChasingGlobalVariable(laser2Rot);
    StopChasingGlobalVariable(laser3Rot);
    laser1Rot = 0;
    laser2Rot = 0;
    laser3Rot = 0;
    rotateLasers = false;

    SmallMessage(AllPlayers(), "Finished rotating");
}

define globalvar outOfRange;

rule: "Laser discharge"
if (doingLasers)
if (lasersReady)
if (rotateLasers)
{
    PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Red, midpoint, 30);

    define knockPlayers = PlayersWithinRadius(midpoint, 15, Team.All, RadiusLOS.Off);
    knockPlayers.knockedFrom = midpoint;
    knockPlayers.force = 40;
    knockPlayers.heightOffset = 1;

    Wait(5);
    LoopIfConditionIsTrue();
}