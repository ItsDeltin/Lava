import "Lava.del";

rule: "Debug Laser Dodge"
Event.OngoingPlayer
if (IsCommunicating(EventPlayer(), Communication.VoiceLineLeft))
{
    doingLasers = !doingLasers;
    rotateLasers = true;
}

define globalvar doingLasers = false;
define globalvar lasersReady ! = false;

define globalvar rotateLasers = false;
define globalvar rotationSpeed = 0; // Number of degrees per second
define globalvar laserLength = 0;
define globalvar boundaryLength = 50;

define globalvar midpoint;

define globalvar laser1Rot;
define globalvar laser2Rot;
define globalvar laser3Rot;

define globalvar laser1Effect !;
define globalvar laser2Effect !;
define globalvar laser3Effect !;
define globalvar ringEffectArray !;
define globalvar outOfRangeHUD !;

// rule: "depression"
// Event.OngoingPlayer
// {
//     CreateHudText(AllPlayers(), isOnLine(laser1Rot, EventPlayer()), null, null, Location.Top);
// }
macro isOnLine(define rotate, define player): AbsoluteValue(cross(rotate, PositionOf(player))) < 100;
macro cross(define rotate, define player)   : dxc(rotate, player) * dyl(rotate) - dyc(rotate, player) * dxl(rotate);
macro dxc(define rotate, define player)     : XOf(player) - XOf(rot(midpoint, rotate, laserLength));
macro dyc(define rotate, define player)     : ZOf(player) - ZOf(rot(midpoint, rotate, laserLength));
macro dxl(define rotate)                    : XOf(midpoint) - XOf(rot(midpoint, rotate, laserLength));
macro dyl(define rotate)                    : ZOf(midpoint) - ZOf(rot(midpoint, rotate, laserLength));

rule: "Setup laser game"
if (doingLasers)
{
    SetGravity(AllPlayers(), 90);

    midpoint = PolePos();

    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        rot(midpoint + Vector(0, 0.5, 0), laser1Rot, laserLength),
        inverseRot(midpoint + Vector(0, 0.5, 0), laser1Rot, laserLength),
        Color.Red,
        EffectRev.VisibleToPositionAndRadius
    );
    laser1Effect = LastCreatedEntity();

    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        rot(midpoint + Vector(0, 2, 0), laser2Rot, laserLength),
        inverseRot(midpoint + Vector(0, 2, 0), laser2Rot, laserLength),
        Color.Red,
        EffectRev.VisibleToPositionAndRadius
    );
    laser2Effect = LastCreatedEntity();

    CreateBeamEffect(
        AllPlayers(),
        BeamType.BadBeam,
        rot(midpoint + Vector(0, 3.5, 0), laser3Rot, laserLength),
        inverseRot(midpoint + Vector(0, 3.5, 0), laser3Rot, laserLength),
        Color.Red,
        EffectRev.VisibleToPositionAndRadius
    );
    laser3Effect = LastCreatedEntity();

    if (rotateLasers)
    {
        // Create the boundary ring
        ringEffectArray = [];
        define fraction ! = 360 / boundarySubdivisions();
        for (define i ! = 0; i < boundarySubdivisions() - 1; i++)
        {
            CreateBeamEffect(
                AllPlayers(),
                BeamType.BadBeam,
                rot(midpoint, fraction * i, boundaryLength),
                rot(midpoint, fraction * (i + 1), boundaryLength),
                Color.Blue,
                EffectRev.None
            );

            ringEffectArray = Append(ringEffectArray, LastCreatedEntity());
        }

        // Warn players to get inside the ring
        outOfRange = AllPlayers();
        CreateHudText(
            VisibleTo:outOfRange,
            Header:IconString(Icon.Warning),
            Text:"Get inside the ring!",
            HeaderColor:Color.Red,
            TextColor:Color.Yellow,
            Location:Location.Top,
            Spectators:Spectators.VisibleNever
        );
        outOfRangeHUD = LastTextID();
    }

    ChaseGlobalVariableOverTime(laserLength, 150, 5, TimeChaseReevaluation.None);
    Wait(5);
    StopChasingGlobalVariable(laserLength);
    lasersReady = true;

    if (rotateLasers)
    {
        ChaseGlobalVariableAtRate(laser1Rot, 360 * 4, rotationSpeed, RateChaseReevaluation.DestinationAndRate);
        ChaseGlobalVariableAtRate(laser2Rot, -(360 * 4), rotationSpeed * 1.25, RateChaseReevaluation.DestinationAndRate);
        ChaseGlobalVariableAtRate(laser3Rot, 360 * 3, rotationSpeed * 0.85, RateChaseReevaluation.DestinationAndRate);

        ChaseGlobalVariableOverTime(rotationSpeed, 45, 5, TimeChaseReevaluation.None);
        Wait(5);
        StopChasingGlobalVariable(rotationSpeed);
    }
}
macro boundarySubdivisions(): 10;

rule: "Clean up lasers"
if (!doingLasers)
if (lasersReady)
{
    lasersReady = false;

    ChaseGlobalVariableOverTime(laserLength, 0, 5, TimeChaseReevaluation.None);
    Wait(5);
    StopChasingGlobalVariable(laserLength);

    DestroyEffect(laser1Effect);
    DestroyEffect(laser2Effect);
    DestroyEffect(laser3Effect);
    DestroyEffectArray(ringEffectArray, 2);
    DestroyHudText(outOfRangeHUD);

    StopChasingGlobalVariable(laser1Rot);
    StopChasingGlobalVariable(laser2Rot);
    StopChasingGlobalVariable(laser3Rot);
    laser1Rot = 0;
    laser2Rot = 0;
    laser3Rot = 0;
    rotateLasers = false;
}

macro rot(define pos, define angle, define length): Destination(pos, DirectionFromAngles(angle, 0), length);
macro inverseRot(define pos, define angle, define length): Destination(pos, DirectionFromAngles(angle + 180, 0), length);

macro intersectingFrom(define rotation, define height): RayCastHitPlayer(rotation, midpoint + height, AllLivingPlayers(), null, false);

macro intersectingRot(define rotation, define height)       : intersectingFrom(       rot(midpoint + Vector(0, height, 0), rotation, laserLength), Vector(0, height, 0));
macro inverseIntersectingRot(define rotation, define height): intersectingFrom(inverseRot(midpoint + Vector(0, height, 0), rotation, laserLength), Vector(0, height, 0));

define playervar lastDamage;

macro getOutOfRange(): RemoveFromArray(AllPlayers(), PlayersWithinRadius(midpoint, boundaryLength, Team.All, RadiusLOS.Off));

rule: "Kill intersecting players"
if (doingLasers)
{
    if (rotateLasers && lasersReady)
    {
        outOfRange = getOutOfRange();
        Damage(outOfRange, null, 4);
    }

    define intersecting = [];

    // laser 1
    intersecting = Append(intersecting, intersectingRot(laser1Rot, 0.5));
    intersecting = Append(intersecting, inverseIntersectingRot(laser1Rot, 0.5));

    // laser 2
    MinWait();
    intersecting = Append(intersecting, intersectingRot(laser2Rot, 2));
    intersecting = Append(intersecting, inverseIntersectingRot(laser2Rot, 2));

    // laser 3
    //intersecting = Append(intersecting, intersectingRot(laser3Rot, 3.5));
    //intersecting = Append(intersecting, inverseIntersectingRot(laser3Rot, 3.5));

    intersecting = FilteredArray(intersecting, ArrayElement() != null && TotalTimeElapsed() - ArrayElement().lastDamage > 1);

    Damage(intersecting, null, 170);

    intersecting.lastDamage = TotalTimeElapsed();

    Wait(0.02);
    LoopIfConditionIsTrue();
}

rule: "Finished rotating"
if (doingLasers)
if (lasersReady)
if (rotateLasers)
if (laser1Rot == 360 * 4)
if (laser2Rot == -(360 * 4))
if (laser3Rot == 360 * 3)
{
    DestroyHudText(outOfRangeHUD);
    DestroyEffectArray(ringEffectArray, 2);
    StopChasingGlobalVariable(laser1Rot);
    StopChasingGlobalVariable(laser2Rot);
    StopChasingGlobalVariable(laser3Rot);
    laser1Rot = 0;
    laser2Rot = 0;
    laser3Rot = 0;
    rotateLasers = false;

    SmallMessage(AllPlayers(), "Finished rotating");
}

define globalvar outOfRange;

rule: "Laser discharge"
if (doingLasers)
if (lasersReady)
if (rotateLasers)
{
    PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Red, midpoint, 30);

    define knockPlayers = PlayersWithinRadius(midpoint, 15, Team.All, RadiusLOS.Off);
    knockPlayers.knockedFrom = midpoint;
    knockPlayers.force = 40;
    knockPlayers.heightOffset = 1;

    Wait(5);
    LoopIfConditionIsTrue();
}