import "Lava.del";
import "Ball.del";

globalvar define goalEffects;

globalvar define blueScore = 0;
globalvar define redScore = 0;
globalvar define totalScore = 0;

rule: "Switch gamemode"
if (totalScore != 0)
if (totalScore % 5 == 0)
{
    AllPlayers().gamemodeTransition = true;
    Wait(1);
    if (gamemode == Mode.Soccer) gamemode = Mode.Volleyball;
    else if (gamemode == Mode.Volleyball) gamemode = Mode.Dodgeball;
    else gamemode = Mode.Soccer;
    
    SpawnPlayers();
}

void SpawnPlayers() "Spawn Players"
{
    AllPlayers().inputEnabled = false;
    InitSpawns();
    respawnBall();

    for (define i = 3; i > 0; i--)
    {
        SmallMessage(AllPlayers(), i);
        Wait(1);
    }
    BigMessage(AllPlayers(), "Start!");
    AllPlayers().inputEnabled = true;
}

void InitSpawns()
{
    Heal(AllPlayers(), null, 9999);
    define blue = RandomizedArray(AllPlayers(Team.Team1));
    define red = RandomizedArray(AllPlayers(Team.Team2));

    for (define i = 0; i < 5; i++)
    {
        if (i < CountOf(blue) && !blue[i].isWorkingDummy) Teleport(blue[i], Vector(60, 154.88, (150 - 30) + (((150 + 30) - (150 - 30))/5)*i));
        if (i < CountOf(red) && !red[i].isWorkingDummy) Teleport(red[i], Vector(-60, 154.88, (150 - 30) + (((150 + 30) - (150 - 30))/5)*i));
    }
    Resurrect(AllPlayers());
    CancelPrimaryAction(AllPlayers());
    AllPlayers().setFacing = true;
}

playervar define setFacing = false;
rule: "Set Facing"
Event.OngoingPlayer
if (setFacing)
{
    setFacing = false;
    MinWait();
    SetFacing(EventPlayer(), DirectionTowards(EyePosition(EventPlayer()), TopPolePos()), Relative.ToWorld);
}

rule: "Football: Start/Stop"
if (IsCommunicating(HostPlayer(), Communication.VoiceLineUp))
{
    if (gamemode != Mode.Soccer) gamemode = Mode.Soccer;
    else gamemode = Mode.Waiting;
}


globalvar define blueGoalSize;
globalvar define redGoalSize;
define considerBallPos: PositionOf(rootBall);
define goalMod(define goalPos): Max(1 - (DistanceBetween(rootBall, goalPos) / 15), 0) * 10;
Vector nearestPlanePoint(define pointPosition, define planePosition, define planeNormal): pointPosition + (-DotProduct(planeNormal, pointPosition - planePosition) / DotProduct(planeNormal, planeNormal)) * planeNormal;
Vector rightOf(Vector dir): Normalize(dir.CrossProduct(Up()));
Vector upOf(Vector dir): Normalize(dir.CrossProduct(dir.CrossProduct(Up())));
Vector signedDistance(define pointPosition, define planePoint, define planeNormal): DotProduct(planeNormal, (pointPosition - planePoint));
// blue
Vector blueNearest: nearestPlanePoint(considerBallPos, bluePos, blueNormal);
Vector bluePos: Vector(115.69, 156.68, 148.52);
Vector blueNormal: Vector(-0.90, 0.43, 0);
// red
Vector redNearest: nearestPlanePoint(considerBallPos, redPos, redNormal);
Vector redPos: Vector(-118.45, 156.68, 148.52);
Vector redNormal: Vector(0.90, 0.43, 0);

define g_down(define p, define d, define size): p + upOf(d) * size;
define g_right(define p, define d, define size): p - rightOf(d) * size;
define g_up(define p, define d, define size): p - upOf(d) * size;
define g_left(define p, define d, define size): p + rightOf(d) * size;

define MakeBeam(Color color, ref define s, ref define e)
{
    CreateBeamEffect(AllPlayers(), BeamType.GoodBeam, s, e, color, EffectRev.VisibleToPositionAndRadius);
    return LastCreatedEntity();
}

void MakeBeams(Color color, ref define nearest, ref define normal, ref define size, ref define effectStart)
{
    goalEffects[effectStart]     = MakeBeam(color, g_up(nearest, normal, size), g_right(nearest, normal, size));
    goalEffects[effectStart + 1] = MakeBeam(color, g_right(nearest, normal, size), g_down(nearest, normal, size));
    goalEffects[effectStart + 2] = MakeBeam(color, g_down(nearest, normal, size), g_left(nearest, normal, size));
    goalEffects[effectStart + 3] = MakeBeam(color, g_left(nearest, normal, size), g_up(nearest, normal, size));
}

rule: "Football: Blue Diamond"
if (blueInRange)
{
    MakeBeams(Color.Team1, redNearest, redNormal, redGoalSize, 4);
    redGoalSize = 0;
    ChaseVariableAtRate(redGoalSize, goalMod(redNearest), 30, RateChaseReevaluation.DestinationAndRate);
}
rule: "Football: Destroy Blue Diamond"
if (!blueInRange)
{
    DestroyEffect(goalEffects[4]);
    DestroyEffect(goalEffects[5]);
    DestroyEffect(goalEffects[6]);
    DestroyEffect(goalEffects[7]);
}
rule: "Football: Red Diamond"
if (redInRange)
{
    MakeBeams(Color.Team2, blueNearest, blueNormal, blueGoalSize, 0);
    blueGoalSize = 0;
    ChaseVariableAtRate(blueGoalSize, goalMod(blueNearest), 30, RateChaseReevaluation.DestinationAndRate);
}
rule: "Football: Destroy Red Diamond"
if (!redInRange)
{
    DestroyEffect(goalEffects[0]);
    DestroyEffect(goalEffects[1]);
    DestroyEffect(goalEffects[2]);
    DestroyEffect(goalEffects[3]);
}

define blueInRange: PositionOf(rootBall).X < -80;
define redInRange: PositionOf(rootBall).X > 80;

rule: "Football: Destroy goals"
if (gamemode != Mode.Soccer)
{
    foreach (define effect in goalEffects) DestroyEffect(effect);
    StopChasingVariable(blueGoalSize);
    StopChasingVariable(redGoalSize);
}

rule: "Football: Blue score"
if (ballReady)
if (gamemode == Mode.Soccer)
if (signedDistance(considerBallPos, redPos, redNormal) < 0)
{
    Score(Color.Team1, Team.Team1, redNearest, () => {
        blueScore++;
        ChaseVariableOverTime(redGoalSize, 0, 0.3, TimeChaseReevaluation.None);
    });
}

rule: "Football: Red score"
if (ballReady)
if (gamemode == Mode.Soccer)
if (signedDistance(considerBallPos, bluePos, blueNormal) < 0)
{
    Score(Color.Team2, Team.Team2, blueNearest, () => {
        redScore++;
        ChaseVariableOverTime(blueGoalSize, 0, 0.3, TimeChaseReevaluation.None);
    });
}

void Score(Color teamColor, ref define team, define nearest, BlockLambda score)
{
    totalScore++;
    score.Invoke();

    Wait(0.35);

    PlayEffect(AllPlayers(), PlayEffect.RingExplosion, teamColor, nearest, 100);
    PlayEffect(AllPlayers(team), PlayEffect.BuffExplosionSound, Color.White, nearest, 1000);
    PlayEffect(AllPlayers(OppositeTeamOf(team)), PlayEffect.DebuffImpactSound, Color.White, nearest, 1000);
    messageThrower(team, teamColor);

    SetSlowMotion(25);
    Wait(1);
    SetSlowMotion(100);
}


// define Flatten(Vector vec): vec*Vector(1, 0, 1);
// define FootballDistCalc(define ballPosition, define playerPosition): Min(DistanceBetween(Flatten(ballPosition), Flatten(playerPosition)), 50);

// define footballSlope: (175 - 100) / 50;
// define FootballMoveSpeed(define ballPosition, define playerPosition): 100 + footballSlope * (FootballDistCalc(ballPosition, playerPosition));

// rule: "Football: Increase player movement speed as distance from ball increases"
// Event.OngoingPlayer
// if(gamemode == 2){
//     while(gamemode == 2){
//         SetMoveSpeed(EventPlayer(), FootballMoveSpeed(PositionOf(rootBall), PositionOf(EventPlayer())));
//         Wait(0.032);
//     }
// }



void messageThrower(define team, Color teamColor)
{
    scoreboardOrder++;
    if (TeamOf(thrower) != team)
    {
        BigMessage(AllPlayers(), <"Wrong goal, <0>!", thrower>);
        ThrowHud(teamColor, IconString(Icon.X));
    }
    else if (throwType == 0)
    {
        BigMessage(AllPlayers(), <"<0> scored a hammer shot!", thrower>);
        ThrowHud(teamColor, AbilityIconString(Hero.Reinhardt, ButtonValue(Button.PrimaryFire)));
    }
    else if (throwType == 1)
    {
        BigMessage(AllPlayers(), <"<0> scored a bump shot!", thrower>);
        ThrowHud(teamColor, AbilityIconString(Hero.Doomfist, ButtonValue(Button.Ability1)));
    }
    else if (throwType == 2)
    {
        BigMessage(AllPlayers(), <"<0> scored a charge shot!", thrower>);
        ThrowHud(teamColor, AbilityIconString(Hero.Reinhardt, ButtonValue(Button.Ability1)));
    }
    else if (throwType == 3)
    {
        BigMessage(AllPlayers(), <"<0> scored a fire shot!", thrower>);
        ThrowHud(teamColor, AbilityIconString(Hero.Reinhardt, ButtonValue(Button.Ability2)));
    }
}

globalvar define scoreboardOrder = 0;

void ThrowHud(Color color, ref define icon)
{
    CreateHudText(
        VisibleTo   : AllPlayers(),
        Text        : <"<0><1>", icon, thrower>,
        Location    : Location.Right,
        SortOrder   : scoreboardOrder,
        TextColor   : color,
        Reevaluation: HudTextRev.VisibleTo,
        Spectators  : Spectators.VisibleAlways
    );
}